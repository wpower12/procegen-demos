/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/js/dungeons_00_simple.js":
/*!**************************************!*\
  !*** ./src/js/dungeons_00_simple.js ***!
  \**************************************/
/***/ (() => {

eval("const cnv = document.getElementById(\"cnv\");\nconst ctx = cnv.getContext('2d');\n\nconst MAX_ITERATIONS = 200;\n \nvar input_cellsize  = document.getElementById(\"cell_size\");\nvar input_numrooms  = document.getElementById(\"num_rooms\");\nvar input_maxsize   = document.getElementById(\"max_size\");\nvar btn_gen_dungeon = document.getElementById(\"gen_dungeon_btn\");\n\nbtn_gen_dungeon.onclick = function(e){\n\tlet grid  = defineMaxGrid(cnv, input_cellsize.value);\n\tlet rooms = generateRooms(grid, input_numrooms.value, input_maxsize.value);\n\tlet halls = generateHallways(rooms, grid);\n\n\tdrawGrid(ctx, grid, input_cellsize.value);\n\tdrawHallways(ctx, halls, grid, input_cellsize.value);\n\tdrawRooms(ctx, rooms, grid, input_cellsize.value);\n}\nbtn_gen_dungeon.click();\n\n// Forces the canvas to fill its parents width, and then\n// computes the offsets and extents for the grid based on\n// the dimensions and cell size. \nfunction defineMaxGrid(canvas, cell_size){\n\tcanvas.style.width = \"100%\";\n\tcanvas.width = canvas.offsetWidth;\n\tlet X = Math.floor(canvas.width/cell_size);\n    let Y = Math.floor(canvas.height/cell_size);\n\treturn { 'X': X, 'Y': Y,\n\t\t\t 'os_x': (canvas.width-X*cell_size)/2,\n\t\t\t 'os_y': (canvas.height-Y*cell_size)/2 };\n}\n\n// Return a list of non-overlapping rectangles, representing rooms. \nfunction generateRooms(grid, num_rooms, max_l){\n\tlet rooms = [];\n\tlet num_iterations = 0;\n\twhile(rooms.length < num_rooms){\n\t\tlet c_w = getRandomInt(4, max_l);\n\t\tlet c_h = getRandomInt(4, max_l);\n\t\tlet c_x = getRandomInt(0, grid.X-c_w);\n\t\tlet c_y = getRandomInt(0, grid.Y-c_h);\n\t\tlet new_room = {'x': c_x, 'y': c_y, 'w': c_w, 'h': c_h};\n\t\tlet new_pad_room = {'x': c_x-1, 'y': c_y-1, 'w': c_w+1, 'h': c_h+1};\n\t\tlet collided = false;\n\t\trooms.forEach(function(room){ \n\t\t\tlet pad_room = {'x': room.x-1, 'y': room.y-1, 'w': room.w+1, 'h': room.h+1};\n\t\t\tif(intersect(pad_room, new_pad_room)){ \n\t\t\t\tcollided = true;\n\t\t\t}\n\t\t});\n\t\tif(!collided){\n\t\t\trooms.push(new_room);\n\t\t}\n\t\tif(num_iterations++ > MAX_ITERATIONS){\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn rooms;\n}\n\nfunction generateHallways(rooms, grid){\n\tlet rs = rooms.slice();\n\tlet connected = []\n\tlet hallways = [];\n\twhile(rs.length > 0){\n\t\tlet room = rs.pop();\n\t\tif(connected.length > 0){\n\t\t\t// randomly pick a room and make a hallway to it.\n\t\t\tvar to_room = connected[Math.floor(Math.random()*connected.length)];\n\t\t\tlet mp1 = {'x': Math.floor(room.x+(room.w/2)),\n\t\t\t\t\t   'y': Math.floor(room.y+(room.h/2))};\n\t\t\tlet mp2 = {'x': Math.floor(to_room.x+(to_room.w/2)), \n\t\t\t\t\t   'y': Math.floor(to_room.y+(to_room.h/2))};\n\t\t\thallways.push(findPath(mp1, mp2, grid));\n\t\t} \n\t\tconnected.push(room);\n\t}\n\treturn hallways;\n}\n\nfunction adjacentNodes(p, grid){\n\tlet deltas = [[0,1], [1,0], [-1,0], [0,-1]];\n\tlet neighbors = [];\n\tdeltas.forEach(function(d){\n\t\tif( d[0]+p.x > 0 && \n\t\t\td[0]+p.x < grid.X &&\n\t\t\td[1]+p.y > 0 && \n\t\t\td[1]+p.y < grid.Y ){\n\t\t\tneighbors.push({\n\t\t\t\t'x': d[0]+p.x,\n\t\t\t\t'y': d[1]+p.y\n\t\t\t});\n\t\t}\n\t});\n\tshuffle(neighbors); // makes the paths look interesting. \n\treturn neighbors;\n}\n\n// bfs with a random heuristic to find a (non-optimal-probably) path. \nfunction findPath(p1, p2, grid){\n\tlet visited = [];  // 2d array of the grid. \n\tfor(var i=0; i<grid.X; i++){\n\t\tlet new_col = [];\n\t\tfor(var j=0; j<grid.Y; j++){\n\t\t\tnew_col.push(false);\n\t\t}\n\t\tvisited.push(new_col);\n\t}\n\n\tlet paths = [];    // queue of paths\n\tpaths.push([p1]);\n\twhile(paths.length > 0){\n\t\tpath = paths.shift();\n\t\tlast_node = path.at(-1);\n\t\tif(last_node.x == p2.x && last_node.y == p2.y){\n\t\t\treturn path;\n\t\t}\n\n\t\tadjacentNodes(last_node, grid).forEach(function(n){\n\t\t\tif(!visited[n.x][n.y]){\n\t\t\t\tlet new_path = path.slice();\n\t\t\t\tnew_path.push(n);\n\t\t\t\tpaths.push(new_path);\n\t\t\t\tvisited[n.x][n.y] = true;\n\t\t\t}\n\t\t});\n\t}\n}\n\n// Draws the 'grid' by just drawing a square with cell_size-2 sides\n// in every cell. Its that or deal with borders explicitly idk. \nfunction drawGrid(c, grid, cell_size){\n\tfor (var i = 0; i < grid.X; i++) {\n\t\tfor (var j = 0; j < grid.Y; j++) {\n\t\t\tc.fillStyle = 'grey';\n\t\t\tc.fillRect(grid.os_x+i*cell_size+1, \n\t\t\t\t\t   grid.os_y+j*cell_size+1,\n\t\t\t\t\t\tcell_size-2, cell_size-2);\n\t\t}\n\t}\n}\n\nfunction drawHallways(ctx, halls, grid, cell_size){\n\thalls.forEach(function(cells){\n\t\tcells.forEach(function(cell){\n\t\t\tctx.fillStyle = 'black';\n\t\t\tctx.fillRect(grid.os_x+cell.x*cell_size+1,\n\t\t\t\t\t\t grid.os_y+cell.y*cell_size+1,\n\t\t\t\t\t\t cell_size-2, cell_size-2);\n\t\t})\n\t});\n}\n\nfunction drawRooms(ctx, rooms, grid, cell_size){\n\tctx.fillStyle = \"lightblue\";\n\trooms.forEach(function(room){\n\t\tctx.fillRect(grid.os_x+room.x*cell_size,\n\t\t\t\t\t grid.os_y+room.y*cell_size,\n\t\t\t\t\t room.w*cell_size,\n\t\t\t\t\t room.h*cell_size);\n\t});\n}\n\n// *** Utils ------------\n// from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random\nfunction getRandomInt(min, max) {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive\n}\n\n// from: https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection\nfunction intersect(rect1, rect2){\n\treturn(rect1.x < rect2.x + rect2.w &&\n\t\trect1.x + rect1.w > rect2.x &&\n\t\trect1.y < rect2.y + rect2.h &&\n\t\trect1.h + rect1.y > rect2.y)\n}\n\n// from: https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\nfunction shuffle(array) {\n  let currentIndex = array.length,  randomIndex;\n\n  // While there remain elements to shuffle...\n  while (currentIndex != 0) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex--;\n    // And swap it with the current element.\n    [array[currentIndex], array[randomIndex]] = [\n      array[randomIndex], array[currentIndex]];\n  }\n  return array;\n}\n\n//# sourceURL=webpack://procgen/./src/js/dungeons_00_simple.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./src/js/dungeons_00_simple.js"]();
/******/ 	
/******/ })()
;